22.08.2012 Opcode A6 dekoduje siê na: -> A6             CMPS BYTE PTR DS:[ESI],BYTE PTR ES:[EDI]
Nale¿y zastanowiæ siê jak zakodowaæ taki tryb adresowania gdzie rejestr ogolnego przeznaczenia i rejestr adresowy s¹ podane bezpoœrednio.

02.09.2012
Zastanowiæ siê wrescie nad implementacja DS, ES itd rejestrów segmentowych.

06.10.2012
Branch hints:
• 2EH—Branch not taken (used only with Jcc instructions)
• 3EH—Branch taken (used only with Jcc instructions)

14.10.2012
Sprawdziæ segment register dla trybów adreowania la instrukcji skoków, czy DS , czy moze CS takih jak CALL, bo aktualnie wszystkie
dotaja DS.

Dodaæ renderowanie rjestrów segmentowych.

Podczas assemblacji dodaæ obs³ugê: CMPSW/CMPSD/CMPSQ

Dodaæ mo¿liwoœæ dodawania warningów podczas disassemblacji, i dodawania kilku do kontekstu.

Usun¹æ flagi LOCK, z operacji AVX, bo w czêœci zostala!

Sprawdzic i uzupelnic VVVV unued.

Zrezygnowac z opcode flags [przynajmniej z R/M na rzecz wstepnej analizy operandow instrukcji, a nastepnie wykorzystaniu tej informacji przy wyboerze isntrukcji. Informacja z opcode flags jest porpostu nadmiarowa, mozna to wyliczyc analizujac operandy.
Kazdy operand musial by posiadac mozliwosc odawania jakiegos filtr flag czy cos w tym rodzaju.

Any VEX-encoded GPR instruction with a 66H, F2H, or F3H prefix preceding VEX will #UD.
Any VEX-encoded GPR instruction with a REX prefix proceeding VEX will #UD.
VEX-encoded GPR instructions are not supported in real and virtual 8086 modes.



Regu³y:
1. Jeden immediate value mo¿e byæ wykorzystany do zdekodowania kilku operandów. Czyli, jeden operand dekoder przyk³¹dowo mo¿e zdekodowaæ 2 operandy, gryzie sie to troche z naszym zlozeniem, ze jeden operand do jednego dekodera.
2. Instrukcje moga miec do 5 operandow (Moze zrezygnowaæ ze sztywnego okreslania maksymalnej liczby operandow, tylko zastosowac jakœæ liste)
3. Zastanowic sie nad mozliwoscia zaznaczenia, ¿e wybrana instrukcja nie moze posiadac danych prefixow. A moze domyslnie intrucje SIMD ni zpozwalaja na zadne manadatory,  chyba ze te ktorych wymagaja. Pewnie tak jest.
4. Oeprandy moga wyznaczac warosi warunkow dla instrukcji warunkowych.



// Zpomniame toodo:

// TODO: Zastanowic sie czy do sterowania flagami nie da ie wykorzystac nowych bitow MOD3 ModNot3 zamiast bezposredniego ich podawania.
#define _IRA_OPERAND_RM_BASE						0x17000000
#define _IRA_OPERAND_RM(reg_type, encoded_register_operand_size, encoded_memory_operand_size, flags )		( _IRA_OPERAND_RM_BASE | encoded_memory_operand_size << 16 | encoded_register_operand_size << 8 | reg_type << 4 | flags )
#define _IRA_OPERAND_RM_W(reg_type, encoded_register_operand_size, encoded_memory_operand_size, flags )		( _IRA_OPERAND_RM(reg_type, encoded_register_operand_size, encoded_memory_operand_size, flags) | _IRA_WRITE )

03.09.2013
Dodac mozliwoœc assemblacji instrucji XOP/VEX z prefixem C4 je¿eli mozna zastosowac krotszy C5.

08.09.2013
Dodac mozliwosc disassemblacji pseudo opcode, jezeli odpowiednia opcja konfiguracyjna jest wlaczona.

21.09.2013
Dodac hinty, za pomoca ktorych bedzie mozliwosc assemblacji instruckji o okreslonej wielkosci operandu, przykladowo jmp rel8 a jmp rel32, dla -1 zostanie wybrane 8 bitow a mozemy chciec 32.
Zastanowic sie przy okazji nad niekonsekwencja assemlacji, czesc zotawiamy do wyboru optimizerom a czesc trybow adresowania sama decyduje jak optymalizowac ModRM/XOP/VEX 2-3 bajtyprefix.(W tym przypadku optymalizowanie ModRM) 
