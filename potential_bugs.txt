1. CALL bug in VS.

IRA    (66ff5701 call qword ptr [rdi+0000000000000001h])
VS2008 (66ff5701 call word [rdi+1])

Manual says:
"When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits"

So it's probably a bug in VS.

TODO: To check how it really works using example code ad debugging.

2. JMP bug in VS.

Manual says:
In 64-Bit Mode — The instruction’s operation size is fixed at 64 bits.

0000000000401000 48 EB FF         jmp         0000000000401002 
0000000000401003 66 EB FF         jmp         0000000000001005 <-- It's uses operand size 16, when operand size is forced to 64 bits. 
0000000000401006 67 EB FF         jmp         0000000000401008 
0000000000401009 EB FF            jmp         000000000040100A 
000000000040100B E3 FF            jrcxz       000000000040100C 
000000000040100D 67 E3 FF         jecxz       000000000040100F 
0000000000401010 66 E3 FF         jrcxz       0000000000001012 <-- The same problem as above.
0000000000401013 67 66 E3 FF      jecxz       0000000000001016 <-- The same problem as above.

3. CRC32 Disassemblation bug.

Starting with an initial value in the first operand (destination operand), accumulates
a CRC32 (polynomial 0x11EDC6F41) value for the second operand (source operand)
and stores the result in the destination operand. The source operand can be a
register or a memory location. The destination operand must be an r32 or r64
register. If the destination is an r64 register, then the 32-bit result is stored in the
least significant double word and 00000000H is stored in the most significant double
word of the r64 register.

So disassembler shouldn't respect 0x66 prefix:

66f20f38f04020  crc32   ax,byte ptr [rax+20h] (Wrong!)

4. DIV Disassemblation bug.

Result is stored in AX not AL!

00000000`00401000 48f6f6          div     al,sil

5. FPU bug.

00000000`00401000 9b              wait
00000000`00401001 dbe2            fnclex
00000000`00401003 dbe2            fnclex

Fist instruction should be disassembled to: 9bdbe2 fclex


6. FPU bug.

00000000`00401000 9b              wait
00000000`00401001 dbe3            fninit

Fist instruction should be disassembled to: 9bdbe3 finit

7. FPU bug.

0000000`00401000 480fae4820      fxrstor [rax+20h]     ds:00000000`77416540=65

-> 480fae4820 fxrstor64 512byte ptr [rax+0000000000000020h]

8. IN bug.

00000000`00401000 e520            in      eax,20h
00000000`00401002 66e520          in      ax,20h
00000000`00401005 e420            in      al,20h
00000000`00401007 48e520          in      rax,20h <-- This operand size is not allowed.


9. INS

00000000`00401000 486d            ins     qword ptr [rdi],dx ds:00000000`00000000=????????????????
 -->
486d ins dword ptr [rdi],dx

10. 

00000000`00401000 0f026820        lar     ebp,dword ptr [rax+20h]
00000000`00401004 660f026820      lar     bp,word ptr [rax+20h]

-->

Wrong operand size! (Ignore the fact that instructions were disassembled in different modes it doesn't matter)

0f026820 lar ebp,word ptr [eax+00000020h]
660f026820 lar bp,word ptr [eax+00000020h]

11.

00000000`00401000 0f015020        lgdt    fword ptr [rax+20h] ds:00000000`77386540=3025048b4865
00000000`00401004 660f015020      lgdt    fword ptr [rax+20h]
00000000`00401009 480f015020      lgdt    fword ptr [rax+20h]

--->

_TEST64( "0f015020 lgdt fword ptr [rax+0000000000000020h]", 0x0F, 0x01, 0x50, 0x20 );
_TEST64( "660f015020 lgdt fword ptr [rax+0000000000000020h]", 0x66, 0x0F, 0x01, 0x50, 0x20 );
_TEST64( "480f015020 lgdt tbyte ptr [rax+0000000000000020h]", 0x48, 0x0F, 0x01, 0x50, 0x20 );
	
