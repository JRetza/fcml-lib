1. CALL bug in VS.

IRA    (66ff5701 call qword ptr [rdi+0000000000000001h])
VS2008 (66ff5701 call word [rdi+1])

Manual says:
"When in 64-bit mode, the operand size for near call (and all near branches) is forced to 64-bits"

So it's probably a bug in VS.

TODO: To check how it really works using example code ad debugging.

2. JMP bug in VS.

Manual says:
In 64-Bit Mode � The instruction�s operation size is fixed at 64 bits.

0000000000401000 48 EB FF         jmp         0000000000401002 
0000000000401003 66 EB FF         jmp         0000000000001005 <-- It's uses operand size 16, when operand size is forced to 64 bits. 
0000000000401006 67 EB FF         jmp         0000000000401008 
0000000000401009 EB FF            jmp         000000000040100A 
000000000040100B E3 FF            jrcxz       000000000040100C 
000000000040100D 67 E3 FF         jecxz       000000000040100F 
0000000000401010 66 E3 FF         jrcxz       0000000000001012 <-- The same problem as above.
0000000000401013 67 66 E3 FF      jecxz       0000000000001016 <-- The same problem as above.

3. CRC32 Disassemblation bug.

Starting with an initial value in the first operand (destination operand), accumulates
a CRC32 (polynomial 0x11EDC6F41) value for the second operand (source operand)
and stores the result in the destination operand. The source operand can be a
register or a memory location. The destination operand must be an r32 or r64
register. If the destination is an r64 register, then the 32-bit result is stored in the
least significant double word and 00000000H is stored in the most significant double
word of the r64 register.

So disassembler shouldn't respect 0x66 prefix:

66f20f38f04020  crc32   ax,byte ptr [rax+20h] (Wrong!)

4. DIV Disassemblation bug.

Result is stored in AX not AL!

00000000`00401000 48f6f6          div     al,sil

5. FPU bug.

00000000`00401000 9b              wait
00000000`00401001 dbe2            fnclex
00000000`00401003 dbe2            fnclex

Fist instruction should be disassembled to: 9bdbe2 fclex


6. FPU bug.

00000000`00401000 9b              wait
00000000`00401001 dbe3            fninit

Fist instruction should be disassembled to: 9bdbe3 finit

7. FPU bug.

0000000`00401000 480fae4820      fxrstor [rax+20h]     ds:00000000`77416540=65

-> 480fae4820 fxrstor64 512byte ptr [rax+0000000000000020h]

8. IN bug.

00000000`00401000 e520            in      eax,20h
00000000`00401002 66e520          in      ax,20h
00000000`00401005 e420            in      al,20h
00000000`00401007 48e520          in      rax,20h <-- This operand size is not allowed.


9. INS

00000000`00401000 486d            ins     qword ptr [rdi],dx ds:00000000`00000000=????????????????
 -->
486d ins dword ptr [rdi],dx

10. 

00000000`00401000 0f026820        lar     ebp,dword ptr [rax+20h]
00000000`00401004 660f026820      lar     bp,word ptr [rax+20h]

-->

Wrong operand size! (Ignore the fact that instructions were disassembled in different modes it doesn't matter)

0f026820 lar ebp,word ptr [eax+00000020h]
660f026820 lar bp,word ptr [eax+00000020h]

11.

00000000`00401000 0f015020        lgdt    fword ptr [rax+20h] ds:00000000`77386540=3025048b4865
00000000`00401004 660f015020      lgdt    fword ptr [rax+20h]
00000000`00401009 480f015020      lgdt    fword ptr [rax+20h]

--->

_TEST64( "0f015020 lgdt fword ptr [rax+0000000000000020h]", 0x0F, 0x01, 0x50, 0x20 );
_TEST64( "660f015020 lgdt fword ptr [rax+0000000000000020h]", 0x66, 0x0F, 0x01, 0x50, 0x20 );
_TEST64( "480f015020 lgdt tbyte ptr [rax+0000000000000020h]", 0x48, 0x0F, 0x01, 0x50, 0x20 );
	
12.

00000000`00401000 488c10          mov     word ptr [rax],ss ds:00000000`769a6520=0e75c98528ec8348
00000000`00401003 8c10            mov     word ptr [rax],ss

-->

488c10 mov qword ptr [rax],ss
8c10 mov word ptr [rax],ss

13. 

c4c3094b140120  vblendpd ymm2,ymm14,xmmword ptr [r9+rax],20

Powinno by�:

14.

00401000 c4e249181401    vbroadcastss ymm2,dword ptr [ecx+eax] ds:002b:76bf3398=8b55ff8b
00401006 c4e24d181401    vbroadcastss ymm2,dword ptr [ecx+eax]

-->

_TEST32_VEX( "c4e249181401 vbroadcastss xmm2,dword ptr [ecx+eax]", 0xC4, 0xE2, 0x49, 0x18, 0x14, 0x01 );
_TEST32_VEX( "c4e24d181401 vbroadcastss ymm2,dword ptr [ecx+eax]", 0xC4, 0xE2, 0x4D, 0x18, 0x14, 0x01 );

15. Nie dekoduje.

_TEST64_VEX( "c4c178ae10 vldmxcsr dword ptr [r8]", 0xC4, 0xC1, 0x78, 0xAE, 0x10 );
_TEST32_VEX( "c4e178ae10 vldmxcsr dword ptr [eax]", 0xC4, 0xE1, 0x78, 0xAE, 0x10 );
_TEST32_VEX( "c5f8ae10 vldmxcsr dword ptr [eax]", 0xC5, 0xF8, 0xAE, 0x10 );

16.

// EXTRQ xmm1,imm8,imm8 66 0F 78 /0 ib ib
// EXTRQ xmm1,xmm2 66 0F 79 /r

W pierwszym przypadku bierze pod uwage ModRM.reg zamiast ModRM.r/m (Patrz /0)

17.
FCML_I32( "vmovlhps xmm2,xmm5,xmm0", 0xC5, 0xD0, 0x16, 0xD0 );
a jest:
c5d016d0        vmovlhps xmm2,xmm0
-- Bug?


fcml_bool fcml_fn_env_is_alpha( fcml_char c ) {
	fcml_uint8_t res = isalpha( c );
	int i = isalpha( c );
	fcml_uint8_t res1 = i;
	res += res1;
	return res;
}


****************
 GAS
****************

Poprawnie:
00401000 > $ D8F0           FDIV ST,ST
00401002   . DCF8           FDIV ST,ST
00401004   . D8F8           FDIVR ST,ST
00401006   . DCF0           FDIVR ST,ST

GDB:
0x00401000:   d8 f0  fdiv   %st(0),%st
0x00401002:   dc f8  fdivr  %st,%st(0)
0x00401004:   d8 f8  fdivr  %st(0),%st
0x00401006:   dc f0  fdiv   %st,%st(0)

0x000000000040050b <main+0>:	d8 f1	fdiv   %st(1),%st
0x000000000040050d <main+2>:	dc f1	fdiv   %st,%st(1)

Powino być:
(0xde, 0xf9) fdivp %st(0),%st(1) jest-> fdivrp %st(0),%st(1)

Sprawdzic czy to faktycznie jest błąd, byc może w dokumentacji jest błąd.

FASM assembluje poprawnie, więc to błąd GDB.
Ale z drugiej strony GAS assemblje podobnie jak GDB, więc chyba by komilatory się wywalały GCC :), do sprawdzenia na procesorze.


