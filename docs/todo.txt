VEX-encoded GPR instructions are not supported in real and virtual 8086 modes.

21.09.2013
// Moze kiedys, aktyalnie mozna to osignac za pomoca odpowiedniego instruction choosera.
Dodac hinty, za pomoca ktorych bedzie mozliwosc assemblacji instruckji o okreslonej wielkosci operandu, przykladowo jmp rel8 a jmp rel32, dla -1 zostanie wybrane 8 bitow a mozemy chciec 32.
Zastanowic sie przy okazji nad niekonsekwencja assemlacji, czesc zotawiamy do wyboru optimizerom a czesc trybow adresowania sama decyduje jak optymalizowac ModRM/XOP/VEX 2-3 bajtyprefix.(W tym przypadku optymalizowanie ModRM) 

3.11.2013
Mozliwosc podawania symbolow podczas parsowania i ich resolving. W zasadzie tylko parser powinien to obslugiwac, dl assemblera trafiac powinein juz address.

Dodac do domyslnego optimizera flage, ktora bedzie umozliwala assemblacje wszystkichopcji, dl wszystkich kombinaji ASA OSA a nie rpzywala po pierwszej akonzonej sukcesem. Przydatne jezei ktos bedzie chcial zobaczyc wszystckie mozliwe opcje assemblacji.

Na koncu konwertowac kod bledu na opis, przyladowo invalid args na nieppoprawne argumenty wyolania itd.

Mozliwosc renderingny intel z RIP jako [rip+disp]

Support hintów dla SIB w przypadku GAS, aktualnie nie obslugujemy.

assemblowac  add dword [ebp],04030201h  , nalezy zwrocic uwage ze aby to zakodowac trzeba niejawnie zakodowac displacemenet = 0.

Ignotowac hinty abs i rel dla dialektu AT&T, poniewaz uzytkownik moze je ustawic poza assemblerem.

Sposob na implementacje nejednoznacznosci w przypadku far call:
Umozliwic stosowanie 2 sposobów zapisu operandow
FAR_POINTER
IMM, IMM
I dopiero po wyborze ADD_MODE przed akceptacją zastosować preprocesor udpostępniany przez dialect, który na podstawie typu instrukcji przykładowo F_CALL, odpowiednio przygotuje
operandy, tak aby dalej juz był wykorzystany zapis FAR_POINTER. Dzięki temu parser bedzie mógł zapisac IMM, IMM a uzytownik sam skladajacy instrukcję będzie miał mozliwośc zapisu
operatora FAR_POINTER.

Zastanowic sie czy dla intela faktycznie nie chcemy domyslnie drukowac hinta indirect, dzieki temu pozbedziemy sie niejednoznacznosci
w przypadku jmp dword [eax] ktory moze zostac zassemblowany jako far jmp oraz near indirect jmp.

Dodac do mnemonic mm wszedzie gdzie ma to sens.

Ddoac metody ktore beda pozwalamy konwertowac format ogolny zapisu instruckcji, kolejnosc operandow itd z intela traktowanego jako domyslny na odpowiadajacy dialektowi
uzywajac takiej metody uzytkownik mogl by zmieniac renderer/dialect a kod analizy zostawiac taki sam. Trudno powiedziec czy to sie uda (mnemoniki sa inne)


Dla multi instrucji dodac dopasowywanie kodu instrukcji, ktory ejst zwracany przez disassembler.

STAC, CLAC jest niesupportowany przez fasm?




- Ustawić wszędzie opcjonalność wielkości pamięci.



1. Register i memory.
2. CRC32, chyba jest konflikt pomimo że rejestr jest podany.
3. VCVTTPD2DQ Także wyjątek.

- 