VEX-encoded GPR instructions are not supported in real and virtual 8086 modes.

21.09.2013
// Moze kiedys, aktyalnie mozna to osignac za pomoca odpowiedniego instruction choosera.
Dodac hinty, za pomoca ktorych bedzie mozliwosc assemblacji instruckji o okreslonej wielkosci operandu, przykladowo jmp rel8 a jmp rel32, dla -1 zostanie wybrane 8 bitow a mozemy chciec 32.
Zastanowic sie przy okazji nad niekonsekwencja assemlacji, czesc zotawiamy do wyboru optimizerom a czesc trybow adresowania sama decyduje jak optymalizowac ModRM/XOP/VEX 2-3 bajtyprefix.(W tym przypadku optymalizowanie ModRM) 

3.11.2013
Mozliwosc podawania symbolow podczas parsowania i ich resolving. W zasadzie tylko parser powinien to obslugiwac, dl assemblera trafiac powinein juz address.

Dodac do domyslnego optimizera flage, ktora bedzie umozliwala assemblacje wszystkichopcji, dl wszystkich kombinaji ASA OSA a nie rpzywala po pierwszej akonzonej sukcesem. Przydatne jezei ktos bedzie chcial zobaczyc wszystckie mozliwe opcje assemblacji.

Na koncu konwertowac kod bledu na opis, przyladowo invalid args na nieppoprawne argumenty wyolania itd.

Mozliwosc renderingny intel z RIP jako [rip+disp]

Support hintów dla SIB w przypadku GAS, aktualnie nie obslugujemy.

assemblowac  add dword [ebp],04030201h  , nalezy zwrocic uwage ze aby to zakodowac trzeba niejawnie zakodowac displacemenet = 0.

Ignotowac hinty abs i rel dla dialektu AT&T, poniewaz uzytkownik moze je ustawic poza assemblerem.

Sposob na implementacje nejednoznacznosci w przypadku far call:
Umozliwic stosowanie 2 sposobów zapisu operandow
FAR_POINTER
IMM, IMM
I dopiero po wyborze ADD_MODE przed akceptacją zastosować preprocesor udpostępniany przez dialect, który na podstawie typu instrukcji przykładowo F_CALL, odpowiednio przygotuje
operandy, tak aby dalej juz był wykorzystany zapis FAR_POINTER. Dzięki temu parser bedzie mógł zapisac IMM, IMM a uzytownik sam skladajacy instrukcję będzie miał mozliwośc zapisu
operatora FAR_POINTER.

Zastanowic sie czy dla intela faktycznie nie chcemy domyslnie drukowac hinta indirect, dzieki temu pozbedziemy sie niejednoznacznosci
w przypadku jmp dword [eax] ktory moze zostac zassemblowany jako far jmp oraz near indirect jmp.

Dodac do mnemonic mm wszedzie gdzie ma to sens.

Ddoac metody ktore beda pozwalamy konwertowac format ogolny zapisu instruckcji, kolejnosc operandow itd z intela traktowanego jako domyslny na odpowiadajacy dialektowi
uzywajac takiej metody uzytkownik mogl by zmieniac renderer/dialect a kod analizy zostawiac taki sam. Trudno powiedziec czy to sie uda (mnemoniki sa inne)


Dla multi instrucji dodac dopasowywanie kodu instrukcji, ktory ejst zwracany przez disassembler.

STAC, CLAC jest niesupportowany przez fasm?


- Ustawić wszędzie opcjonalność wielkości pamięci.
- Ustawić Source/Destination (R/W) dla operandów.


1. Register i memory.
2. CRC32, chyba jest konflikt pomimo że rejestr jest podany.
3. VCVTTPD2DQ Także wyjątek.

1. Read/Write
2. Kodowanie operandów 


LLWPCB <- Co to jest ten lightweight profiling.


---

Hello everyone,

AT&T dialect says, that every instruction has opposite order of destination and source operands in comparison to the Intel syntax. So in fact, all operands are just inverted. Recently, I found out that there are at last two instructions (bound and enter) which seem not to follow the rule. Following example shows how they are currently encoded in GAS/Intel assembler:

INTEL: 62 30     bound esi,[eax]
GAS:   62 30     bound %esi,(%eax)

INTEL: c8 ee ff 01    enter 0ffeeh,01h
GAS:   c8 ee ff 01    enter $0xffee,$0x1
       c8 ee ff 55    enter $0xffee,$0x55
       
As you can see, both of these instructions have the same order of the operands. At first, I though that the fact that they do not have destination operand might be the case, but there are other similar instructions like "maskmovdqu" that follows the rule, so it looks like inconsistency. I haven't found any logical explanation yet, so I would be really grateful
for any information about this issue. Maybe this is expected behaviour (just an exception), or maybe a kind of historical reason?

Thanks in advance.

Regards,
Sławomir Wojtasiak
slawomir *DOT* wojtasiak *AT* swkso[remove me]ftware *DOT* pl





   0x000000000040050b <main+0>:	d8 e3	fsub   %st(3),%st
   
   st0-st3=st0
   
   0x000000000040050d <main+2>:	dc e3	fsub   %st,%st(3)

   st0-st3=st3


Witam wszystkich,

Ostatnio napotkałem na dziwną niekonsystencję w dialekcie AT&T wykorzystywanym przez GAS. 
Wszystkie instrukcje z jakimi się spotkałem mają odwrócone operandy w stosunku do dialektu intelowskiego. Jednak nastepujące dwie instrukcje nie są zgodne z tą konwencją.


       
Myślałem, że to kwestia tego, że w przypadku tych instrukcji ostatni operand nie jest operandem docelowym (Oba są read only.) ale inne podobne instruckje jak na przykład
maskmovdqu assemblują/disassemblują się poprawnie. Czy takie zachowanie jest zamierzone? Czy może jest to jakaś pozostałość historyczna?

Regards,
Sławomir Wojtasiak
slawomir *DOT* wojtasiak *AT* swksoftware *DOT* pl

INTEL:
GAS:   0f ba a7 01 02 03 04 05    btl    $0x5,0x4030201(%edi)

00401000 DC F9            fdiv        st(1),st 
00401002 DC F1            fdivr       st(1),st 
0xdc, 0xf9 - fdivr %st,%st(1)
0xdc, 0xf1 - fdiv  %st,%st(1)

W tym przypadku oba operandy są R/R, ale inne isntrukcje mają podobnie.

Transformery. Czyli próba optymalizacji instrukcji przez jej assemblacja, taka optymalizacja moze zmienic operandy przykładowo:
Okazuje sie ze trafiamy na instrukcje.
 
 bt[l] $63,(%rsi)
>
> ... and turn it into:
>
>         btl $31,4(%rsi)

W deifnicji insturkcji mamy zapisany 