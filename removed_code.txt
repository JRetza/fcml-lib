
int64_t _ira_get_immediate_as_64bit_signed_integer( struct ira_immediate_data *immediate_data ) {
	int64_t immediate;
	switch( immediate_data->immediate_data_type ) {
	case IRA_IMMEDIATE_8:
		immediate = (int8_t)immediate_data->immediate_data.immediate_8;
		break;
	case IRA_IMMEDIATE_16:
		immediate = (int16_t)immediate_data->immediate_data.immediate_16;
		break;
	case IRA_IMMEDIATE_32:
		immediate = (int32_t)immediate_data->immediate_data.immediate_32;
		break;
	case IRA_IMMEDIATE_64:
		immediate = (int64_t)immediate_data->immediate_data.immediate_64;
		break;
	}
	return immediate;
}


#define _IRA_IT_FMA_PD(id,mnemonic,opcode) \
struct ira_opcode_desc _ira_opcode_desc_##id[] = { \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##132pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0x90 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##213pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0xA0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##231pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0xB0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
}

#define _IRA_IT_FMA_PS(id,mnemonic,opcode) \
struct ira_opcode_desc _ira_opcode_desc_##id[] = { \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##132ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0x90 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##213ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0xA0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##231ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0xB0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
}







/*#define _INSTRUCTION_TEMPLATE_BINARY_ARITHMETIC_1( mnemonic, base_opcode, opcode_ext ) { \
		_IRA_ENCODE_OPCODE_FLAGS_OPCODE_EXT
	// base_opcode + 4 ib mnemonic AL,imm8
	{ NULL, 0x0001, 0x00C40000, { 0x14, 0x00, 0x00 }, _IRA_OPERAND_REG_ACCUMULATOR_8, _IRA_OPERAND_IB, _IRA_NA, _IRA_NA },
};*/




if( (scale_factor == 0 || scale_factor == 1 || scale_factor == 2 || scale_factor == 4 ) ) {
		effective_address->scale_factor = (fcml_uint8_t)scale_factor;
	} else {
		if( !fcml_fn_ceh_add_error( error_container, "Wrong scale factor value.", FCML_EN_APC_AST_ERROR_WRONG_VALUE_FORMAT, FCML_EN_CEH_EL_ERROR ) ) {
			error = FCML_CEH_GEC_OUT_OF_MEMORY;
		} else {
			error = FCML_CEH_GEC_DATA_ERROR;
		}
		return error;
	}
	
	
