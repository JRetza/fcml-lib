

		/*
		 *
		 * Previous implementation.

		if( imm <= FCML_UINT8_MAX ) {
			immediate->imm8 = (fcml_uint8_t)imm;
			immediate->imm_size = FCML_DS_8;
		} else if( imm <= FCML_UINT16_MAX ) {
			immediate->imm16 = (fcml_uint16_t)imm;
			immediate->imm_size = FCML_DS_16;
		} else if( imm <= FCML_UINT32_MAX ) {
			immediate->imm32 = (fcml_uint32_t)imm;
			immediate->imm_size = FCML_DS_32;
		} else {
			fcml_int64_t signed_imm = (fcml_int64_t)imm;
			if( signed_imm > FCML_INT32_MAX ) {
				// Value is out of range.
				error = FCML_EN_APC_AST_ERROR_VALUE_OUT_OF_RANGE;
			} else {
				fcml_int32_t signed32_imm = (fcml_int32_t)signed_imm;
				if( signed_imm < 0 ) {
					immediate->is_signed = FCML_TRUE;
					if( signed_imm <= FCML_INT8_MAX && signed32_imm >= FCML_INT8_MIN ) {
						immediate->imm8 = (fcml_uint8_t)(fcml_int8_t)signed_imm;
						immediate->imm_size = FCML_DS_8;
					} else if( signed_imm <= FCML_INT16_MAX && signed32_imm >= FCML_INT16_MIN ) {
						immediate->imm16 = (fcml_uint16_t)(fcml_int16_t)signed_imm;
						immediate->imm_size = FCML_DS_16;
					} else {
						immediate->imm32 = (fcml_uint32_t)signed32_imm;
						immediate->imm_size = FCML_DS_32;
					}
				} else {
					immediate->imm32 = (fcml_uint32_t)signed32_imm;
					immediate->imm_size = FCML_DS_32;
				}
			}
		}
		*/
		
		

int64_t _ira_get_immediate_as_64bit_signed_integer( struct ira_immediate_data *immediate_data ) {
	int64_t immediate;
	switch( immediate_data->immediate_data_type ) {
	case IRA_IMMEDIATE_8:
		immediate = (int8_t)immediate_data->immediate_data.immediate_8;
		break;
	case IRA_IMMEDIATE_16:
		immediate = (int16_t)immediate_data->immediate_data.immediate_16;
		break;
	case IRA_IMMEDIATE_32:
		immediate = (int32_t)immediate_data->immediate_data.immediate_32;
		break;
	case IRA_IMMEDIATE_64:
		immediate = (int64_t)immediate_data->immediate_data.immediate_64;
		break;
	}
	return immediate;
}


#define _IRA_IT_FMA_PD(id,mnemonic,opcode) \
struct ira_opcode_desc _ira_opcode_desc_##id[] = { \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##132pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0x90 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##213pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0xA0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W1 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W1 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##231pd), 0x1088, 0x00EC8000, { 0x0F, 0x38, 0xB0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
}

#define _IRA_IT_FMA_PS(id,mnemonic,opcode) \
struct ira_opcode_desc _ira_opcode_desc_##id[] = { \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##132ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0x90 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##213ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0xA0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
	/* VEX.DDS.128.66.0F38.W0 opcode /r mnemonic xmm0,xmm1,xmm2/m128 */ \
	/* VEX.DDS.256.66.0F38.W0 opcode /r mnemonic ymm0,ymm1,ymm2/m256 */ \
	{ _IRA_DM_STRING(mnemonic##231ps), 0x1090, 0x00EC8000, { 0x0F, 0x38, 0xB0 + opcode }, _IRA_OPERAND_MODRM_R_SIMD_W, _IRA_VEX_VVVV_REG, _IRA_OPERAND_MODRM_RM_SIMD, _IRA_NA }, \
}







/*#define _INSTRUCTION_TEMPLATE_BINARY_ARITHMETIC_1( mnemonic, base_opcode, opcode_ext ) { \
		_IRA_ENCODE_OPCODE_FLAGS_OPCODE_EXT
	// base_opcode + 4 ib mnemonic AL,imm8
	{ NULL, 0x0001, 0x00C40000, { 0x14, 0x00, 0x00 }, _IRA_OPERAND_REG_ACCUMULATOR_8, _IRA_OPERAND_IB, _IRA_NA, _IRA_NA },
};*/




if( (scale_factor == 0 || scale_factor == 1 || scale_factor == 2 || scale_factor == 4 ) ) {
		effective_address->scale_factor = (fcml_uint8_t)scale_factor;
	} else {
		if( !fcml_fn_ceh_add_error( error_container, "Wrong scale factor value.", FCML_EN_APC_AST_ERROR_WRONG_VALUE_FORMAT, FCML_EN_CEH_EL_ERROR ) ) {
			error = FCML_CEH_GEC_OUT_OF_MEMORY;
		} else {
			error = FCML_CEH_GEC_DATA_ERROR;
		}
		return error;
	}
	
	
	
	 fcml_sf_def_tma_immediate_dis_relative *args = (fcml_sf_def_tma_immediate_dis_relative*)addr_mode->addr_mode_args;
    fcml_en_addr_form addr_form = context->assembler_context->addr_form;
    fcml_st_immediate *imm = &(operand_def->immediate);
    fcml_st_immediate destination = {0};

    fcml_en_attribute_size_flag flags = 0;

    switch( args->encoded_imm_size ) {
    case FCML_EOS_EOSA:
        // Check 16 bit relative offset.
        if( addr_form != FCML_AF_64_BIT ) {
            // 16 bit relative addressing is only available in 16 and 32 bit addressing mode.
            flags = FCML_EN_ASF_32;
            fcml_ifn_asm_can_sign_convert_imm( imm, &destination, FCML_DS_16, FCML_DS_16, FCML_EN_ASF_16, &flags );
        } else {
            // In 64 bits addressing mode OSA is forced to 64 bits, all prefixes are ignored.
            flags = FCML_EN_ASF_64;
        }
        break;
    case FCML_EOS_BYTE:
        if( addr_form != FCML_AF_64_BIT ) {
            fcml_ifn_asm_can_sign_convert_imm( imm, &destination, FCML_DS_16, FCML_DS_16, FCML_EN_ASF_16, &flags );
        }
        break;
    default:
        // Unsupported operand size.
        error = FCML_EN_UNSUPPORTED_OPPERAND;
    }

    if( !error ) {
        if( !flags || !fcml_ifn_set_size_flag( &(context->data_size_flags.allowed_effective_operand_size ), flags ) ) {
            FCML_TRACE("Accept relative address: Can not accept offset value." );
            error = FCML_EN_UNSUPPORTED_OPPERAND;
        }
    }

	return error;
